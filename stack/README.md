|      |                | Description                                          |
| ---- | -------------- | ---------------------------------------------------- |
| 3    | 栈、队列和数组 | 栈<br />队列<br />栈和队列的应用<br />数组和特殊矩阵 |

3. 栈的初态和终态均为空，以I和O分别表示入栈和出栈，则出入栈的操作序列可表示为由I和O组成的序列，可以操作的序列称为合法序列，否则称为非法序列。写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false（假定被判定的操作序列已存入一维数组中）。

   算法思想：依次逐一扫描入栈出栈序列（即由“I”和“O”组成的字符串），每扫描至任一一个位置均需检查出栈次数（即“O”的个数）是否小于入栈个数（“I“的个数），若大于则为非法序列。扫描结束后，再判断入栈和出栈次数是否相等，若不相等则为非法序列。

   ```cpp
   bool Judge(char A[])
   {
       int i=0;
       int j=0,k=0;//i为下标，j和k分别为字母I和O的个数
       while(A[i]!='\0')//未到字符数组尾
       {
           switch(A[i])
           {
               case 'I': j++;break;//入栈次数增1
               case 'O':k++;
               if(k>j)
               {
                   printf("序列非法\n");
                   return false;
               }
           }
           i++;//不论A[i]是I还是O，指针i均后移
       }
       if(j!=k)
       {
           printf("序列非法\n");
           return false;
       }
       else
       {
           printf("序列合法\n");
           return true;
       }
   }
   ```

4. 设单链表的表头指针为L，结点结构由data和next两个域构成，其中data域为字符型。试设计算法判断该链表的全部n个字符是否中心对称。例如xyx，xyyx都是中心对称。

   算法思想：使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次进栈。在处理链表的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素，两个元素比较，若相等，则将链表中的下一个元素与栈中再弹出的元素比较，直至链表到尾。这时若栈是空栈，则得出链表中心对称的理论；否则，当链表中的一个元素与栈中弹出元素不等时，结论为链表非中心对称，结束算法的执行。

   ```cpp
   int dc(LinkList L, int n)
   {
       int i;
       char s[n/2];//s字符栈
       LNode *p = L->next;//工作指针p，指向待处理的当前元素
       for(i=0;i<n/2;i++)
       {
           s[i]=p->data;
           p=p->next;
       }
       i--;//恢复最后的i值
       if(n%2==1)//若n是奇数，后移过中心结点
           p=p->next;
       while(p!=NULL&&s[i]==p->data)//检测是否中心对称
       {
           i--;//i充当栈顶指针
           p=p->next;
       }
       if(i==-1)//栈为空栈
           return 1;//链表中心对称
       else
           return 0;//链表不中心对称
   }
   ```

   

5. 设有两个栈S1、S2都采用顺序栈方式，并共享一个存储区[0, ..., maxsize-1]，为了尽量利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式。试设计S1、S2有关入栈和出栈的操作算法。

   两个栈共享向量空间，将两个栈的栈底设在向量两端，初始时，S1栈顶指针为-1，S2栈顶指针为maxsize。两个栈顶指针相邻时为栈满。两个栈顶相向、迎面增长，栈顶指针指向栈顶元素。两个栈入栈和退栈时的栈顶指针的计算。S1栈是通常意义下的栈；而S2栈入栈操作时，其栈顶指针左移（减1），退栈时，栈顶指针右移（加1）。对于所有栈的操作，都要注意”入栈判满、出栈判空“的检查。

   ```cpp
   #define maxsize 100//两个栈共享顺序存储空间所能达到的最多元素数
   #define elemtp int//假设元素类型为整型
   typedef struct{
       elemtp stack[maxsize];//栈空间
       int top[2];//top为两个栈顶指针
   }stk;
   stk s;//s是如上定义的结构类型变量，为全局变量
   
   int push(int i, elemtp x)
   {
   	//入栈操作。i为栈号，i=0表示左边的S1栈，i=1表示右边的S2栈，x是入栈元素
       //入栈成功返回1，否则返回0
       if(i<0||i>1)
       {
           printf("栈号输入不对");
           return -1;
       }
       if(s.top[1]-s.top[0]==1)
       {
           printf("栈已满\n");
           return 0;
       }
       switch(i)
       {
           case 0: s.stack[++s.top[0]]=x; return 1; break;
           case 1: s.stack[--s.top[1]]=x; return 1;
       }
   }
   //退栈操作
   elemtp pop(int i)
   {
       //退栈算法。i代表栈号，i=0表示左边的S1栈，i=1表示右边的S2栈
       //退栈成功返回退栈元素，否则返回-1
       if(i<0||i>1)
       {
           printf("栈号输入不对");
           return -1;
       }
       switch(i)
       {
           case 0:
               if(s.top[0]==-1)
               {
                   printf("栈空\n");
                   return -1;
               }
               else
                   return s.stack[s.top[0]--];
               break;
           case 1:
               if(s.top[1]==maxsize)
               {
                   printf("栈空\n");
                   return -1;
               }
               else
                   return s.stack[s.top[1]++];
               break;
       }
   }
   ```

   